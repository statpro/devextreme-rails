- toolbar_for = options.delete(:toolbar_name) || :toolbar
- content_for(toolbar_for) do

  = render :partial => 'data_tables/grid_toolbar', :locals => local_assigns

-# This will render the download modal - Can't be in `other_body_content` because of master detail
- if download_visible
  = render :partial => 'data_tables/download_modal', :locals => local_assigns

.clearfix
.dxDataGrid-holder{:id => "#{container_id}-holder", :style=> "height: inherit;"}
  - height_style = (height.present?) ? "height: #{height};" : ""
  - width_style = (width.present?) ? "width: #{width};" : ""

  .dxDataGrid-container.well.well-small{:id => "#{container_id}-container", :style => height_style + width_style}
    .dxDataGrid{:id => "#{container_id}"}
    .row-count{:id => "#{container_id}-row_count"}

- unless disable_state_storing
  - # This is bad, we shouldn't be calling sql functions from views.
  - # TODO:: We shouldn't have a dependancy on an external object in the gem.
  - #        Possible solution is to add a requirement for the gem to have a UserGridLayout store(storage mechanism independent).
  - columns_layout = UserGridLayout.get_user_grid_layout(current_user, self.controller_name, self.action_name, data_table.class.name, data_table.additional_layout_key)

- highlighted_result = params[:highlighted_result]
- highlighted_result_is_text = params[:highlighted_result_is_text] || false
#dialog_container

:javascript

  function _resize_#{container_id}() {
    ItemResize($("##{ container_id }"), "#{height}", "#{width}");
  }
  $(window).on('resize', _resize_#{container_id});

  $(function() {
    var dataGrid = $("##{ container_id }");

    var compact_view_json = #{compact_view_json.html_safe};
    var columns_json = [#{columns_json.html_safe}];
    var data_options_json = #{data_options_json.html_safe};

    dataGrid.data("compact-view", compact_view_json);
    dataGrid.data("default-json", columns_json);
    for (var i in data_options_json) {
      dataGrid.data(i, data_options_json[i]);
    }

    // FIXME: this isn't a specific enough jQuery selector when filter_form_id == "form"
    //   since if there is more than one form, it will include them all
    // if all controllers correctly implement url_params, then "converted_load_options"
    //   will contain the necessary values and the filter will work
    var search_params = $("#{filter_form_id}").serialize();

    var user_grid_layouts_save_layout_path = '#{ disable_state_storing ? '' : user_grid_layouts_save_layout_path}';

    var dataSource = new DevExpress.data.CustomStore({
      key: '#{ data_table.base_query.table_name }.id',
      load: function(loadOptions) {
        var d = new $.Deferred();

        var params = {
          format: 'json',
          filterOptions: loadOptions.filter ? JSON.stringify(loadOptions.filter) : "",   //Getting filter options
          sortOptions: loadOptions.sort ? JSON.stringify(loadOptions.sort) : "",  //Getting sort options

          //skip and take are used for paging
          skip: loadOptions.skip, //A number of records that should be skipped
          take: loadOptions.take, //A number of records that should be taken

          requireTotalCount: loadOptions.requireTotalCount,
          search_params: search_params
        };

        localStorage.setItem('sortOptions', params.sortOptions);
        localStorage.setItem('filterOptions', params.filterOptions);

        $.extend(params, #{ converted_load_options.html_safe });

        var request = $.getJSON("#{ data_table.url(self) }", params);
        request.done(function (data) {
          if(data.total_count != undefined) {
            d.resolve(data.items, { totalCount: data.total_count });
          } else {
            d.resolve(data.items);
          }
        });

        var columns_layout = #{ columns_layout.to_json.html_safe};
        if (!#{disable_state_storing} && columns_layout != undefined && columns_layout.columns != undefined && params.skip == 0) {
          var grid = dataGrid.dxDataGrid('instance');

          $.each(columns_layout.columns, function( index, value ) {
            if (value.precision != undefined) {
              grid.columnOption(value.dataField, 'precision', value.precision);
            }
          });
        }
        return d.promise();
      }
    });

    $("##{container_id}-row_count").dxLoadPanel({
      animation: { hide: { delay: 2500 } },
      visible: false,
      showPane: true,
      height: 30,
      width: 150,
      shading: false,
      closeOnOutsideClick: false,
      onShown: function(e){ e.component.hide(); }
    });

    var gridDataSourceConfiguration = { store: dataSource };
    dataGrid.dxDataGrid({
      dataSource: gridDataSourceConfiguration,
      columns: columns_json,
      summary: {
        totalItems: [
          #{ summaries_json.html_safe }
        ],
        calculateCustomSummary: function (options) {
          #{ custom_summary_functions.html_safe }
        }
      },
      #{ options_json.html_safe },
      onContentReady: function(e){
        if (#{requireTotalRowCountIndicator}) {
          var loadpanel = $("##{container_id}-row_count").dxLoadPanel("instance");
          loadpanel.option({
            showIndicator: false,
            message: "Row count: " + e.component.totalCount(),
            position: { of: $('##{container_id} .dx-scrollable-container'), at: 'right top', offset: '-75, 20' }
          });

          loadpanel.show();
        }
        activateJSPlugins();
      }#{ functions.html_safe },
      onRowPrepared: function (rowInfo) {
        if (rowInfo.data && rowInfo.rowType != 'group' && rowInfo.data['#{ data_table.base_query.table_name }'] ) {
          var row_info_data = rowInfo.data['#{ data_table.base_query.table_name }'];

          // Handle rules highlighted_result
          if (row_info_data.id == #{ highlighted_result_is_text ? "'#{highlighted_result}'" : highlighted_result.to_i } && #{highlighted_result.present?}){
            rowInfo.rowElement.addClass('highlighted_result');
          }

          // Handle data table highlight_row
          if (row_info_data.hasOwnProperty('_highlight_row')) {
            highlight_row_data = JSON.parse(row_info_data._highlight_row);

            if (highlight_row_data.highlight_row) {
              rowInfo.rowElement.addClass(highlight_row_data.highlight_row_class);
            }
          }
        }
      },
      stateStoring: {
        #{state_storing_json.html_safe},
        customLoad: function() {

          var custom_layout = #{ columns_layout.to_json.html_safe };
          var grid = dataGrid.dxDataGrid('instance');
          $.each(custom_layout.columns, function( index, value ) {

            if (value.precision != undefined) {
              grid.columnOption(value.dataField, 'format.precision', value.precision);
            }

          });

          return custom_layout;
        },
        customSave: function (gridState) {
          // removing everything we dont need
          delete gridState.pageIndex;
          delete gridState.pageSize;
          delete gridState.allowedPageSizes;
          delete gridState.selectedRowKeys;
          if (localStorage.getItem('sortOptions')) {
            gridState.sortOptions = JSON.parse(localStorage.getItem('sortOptions'));
          }

          if (localStorage.getItem('filterOptions')) {
            gridState.filterOptions = JSON.parse(localStorage.getItem('filterOptions'));
          }

          var grid = dataGrid.dxDataGrid('instance');

          $.each(gridState.columns, function( index, value ) {
            var column = grid.columnOption(value.dataField);
            if (column.format != undefined && column.format.type == "fixedPoint") {
              // Saving precision tto restore in customLoad
              gridState.columns[index].precision = column.format.precision;
            }
          });

          var jGridState = JSON.stringify(gridState);

          $.ajax({
            type: "PUT",
            url: user_grid_layouts_save_layout_path,
            success: function(e) {
              dataGrid.data('default-state-json', gridState)
            },
            data: {
              user_grid_layout: {
                controller_class_name: '#{ self.controller_name}',
                action_name: '#{ self.action_name}',
                grid_name: '#{ data_table.class.name}',
                additional_layout_key: '#{ data_table.additional_layout_key }',
                columns_layout: jGridState
              }
            }
          });
        }
      },
      onContextMenuPreparing: function(e) {
        if(e.target === 'header' && e.column.format != undefined && e.column.format.type == "fixedPoint") {
          if (e.items == undefined) { e.items = []; }
          e.items.push({
            beginGroup: true,
            container_id: "#{container_id}",
            closeMenuOnClick: false,
            column: e.column,
            template: column_header_template_precision,
            onItemClick: function(e) {
              if (e.itemElement.context.type == "button") {
                e.component.hide();
              }
            }
          });
        }
      },
      height: function() {
        if ("#{height}") {
          var dgMargin = dataGrid.outerHeight(true)-dataGrid.outerHeight();
          var containerHeight = $("##{container_id}-container").height();
          return containerHeight - dgMargin;
        } else {
          var screenHeight = $('.navbar-fixed-bottom').offset().top - $('##{container_id}-holder').parent().offset().top;
          var footerHeight = $('footer').height();
          return screenHeight - footerHeight;
        }
      },

      repaintChangesOnly: true,
      onCellPrepared: function(e) {
        if(e.rowType === "data") {
          var data_cell_css_class = e.data['#{data_table.base_query.table_name}'][e.column.dataFieldWithoutTable + '_cell_css_class'];
          if(data_cell_css_class != undefined) {
            e.cellElement.addClass(data_cell_css_class)

            if (!e.data['#{data_table.base_query.table_name}'][e.column.dataFieldWithoutTable] && data_cell_css_class != "") {
              var color = $(e.cellElement).css('background-color');
              var new_cell_background_color_class = (color == 'transparent' ? "dx-cell-error-odd" : "dx-cell-error-even");

              e.cellElement.addClass(new_cell_background_color_class);
            }
          }
        }
      }
    });
  });
